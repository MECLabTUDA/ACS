# ------------------------------------------------------------------------------
# This class builds a descendant of torch.utils.data.Dataset from a 
# mp.data.datasets.dataset and a list of instance indexes.
# ------------------------------------------------------------------------------

from PIL import Image
import torch
from torch.utils.data import Dataset
from torchvision import transforms

class PytorchDataset(Dataset):
    def __init__(self, dataset, ix_lst=None, resize=None, transform_lst=[], norm=None):
        """
        :param dataset: instance of mp.data.datasets.dataset
        :param ix_lst: list specifying the instances of 'dataset' to include.
        If 'None', all which are not in the hold-out dataset are incuded.
        :param resize: resize images into this new size.
        :param transform_lst: a list of torchvision transforms operations.
        :param norm: values to normalize the dataset with the form 
        {'mean': tuple, 'std': tuple}, which can be generated by 
        mp.utils.pytorch.compute_normalization_values
        """
        # Indexes
        if ix_lst is None:
            ix_lst = [ix for ix in range(len(dataset.instances)) if ix not in dataset.hold_out_ixs]
        self.instances = [ex for ix, ex in enumerate(dataset.instances) if ix in ix_lst]

        # Transform
        transform_operations = [transforms.ToTensor()]
        if resize is not None:
            transform_operations.append(transforms.ToPILImage())
            transform_operations.append(transforms.Resize(resize))
            transform_operations.append(transforms.ToTensor())
        transform_operations += transform_lst
        if norm is not None:
            transform_operations.append(transforms.Normalize(mean=norm['mean'], std=norm['std']))
        self.transform = transforms.Compose(transform_operations)

    def __len__(self):
        return len(self.instances)








